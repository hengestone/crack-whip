// A server to handle communication with 'interpreters'
// Taken from crack.net.httpserv.crk, under LGPL

// Conrad Steenberg <conrad.steenberg@gmail.com>

/// HTTP Server Framework.  Usage synopsis:
/// Copyright 2011 Google Inc.

import crack.ascii strip;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.lang SystemError;
import crack.io cerr, StandardFormatter, StringFormatter, Writer, FStr, FileHandle;
import crack.lang AppendBuffer, Buffer, ManagedBuffer, WriteBuffer, CString;
import crack.net Poller, POLLIN, POLLOUT, POLLERR, POLLHUP;
import crack.sys strerror;
import crack.time TimeDelta;
import crack.logger Logger, DEBUG, WARN, INFO, ERROR, FATAL;
import whip.interpreter Interpreter;

/// An Interpreter Server Container
class InterpreterContainer {
  Logger log = {cerr, DEBUG, "progname datetime severity msg"};

  HashMap[int, Interpreter] _interpreters = {};
  Poller _poller = {};
  Array[FileHandle] __toRemove = {};
  int status, refCount;

  oper init() : refCount = 1 {
  }

  void add(Interpreter intp, FileHandle fh){
    _interpreters[fh.fd] = intp;
    _poller.add(fh, POLLIN);
    _poller.setEvents(fh, POLLIN);
  }

  void remove(Interpreter intp, FileHandle fh){
    _interpreters.delete(fh.fd);
    __toRemove.append(fh);
  }

  /// Process a single event.
  /// If 'timeout' is not null, it is the timeout to wait for the next event.
  void processOnce(TimeDelta timeout) {

    // go through the clients, change their events
#~     for (intpItem :in _interpreters)
#~       _poller.setEvents(intpItem.val.getFileHandles(), POLLIN);

    log.debug(FStr() `waiting for an event`);
    result := _poller.wait(timeout);

    log.debug(FStr() `got events: $result`);
    log.debug(FStr() `Poller = $_poller`);

    while (evt := _poller.nx()) {
      if (POLLIN & evt.revents) {
          log.debug(FStr() `  got client read: $(evt.pollable)`);
          _interpreters[evt.pollable.fd].dataReady(evt.pollable);
      } else if (POLLOUT & evt.revents) {
          log.debug(FStr() `  got client writable, ignoring`);
      } else if (POLLERR & evt.revents) {
          log.debug(FStr() `  error on socket $(evt.pollable)`);
      } else {
          log.debug(FStr()  `  Unknown pollable = $(evt.pollable), events = \
                               $(evt.events), revents = $(evt.revents)`);
      }
    }

    // remove pollables that we're done with.
    if (__toRemove) {
      for (p :in __toRemove) {
          log.debug(FStr() `removing $p`);
          _poller.remove(p);
      }
      while (__toRemove)
          __toRemove.delete(0);
      log.debug(FStr() `removals finished`);
    }
  }

  void run() {
    while (true) {
        processOnce(null);
    }
  }
}



