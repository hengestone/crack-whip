// Class serialization/deserialization using supplied functions
import crack.io Formatter, Writer, cout, FDReader, FDWriter, FStr;
import whip.serializer Materializer, Serializer, Serializable;

import crack.lang ManagedBuffer, Buffer, InvalidArgumentError,
                  InvalidResourceError, AssertionError;

import crack.runtime strlen, errno;
import crack.sys strerror;

import crack.ext._mongo bson, bson_cursor,
                        bson_new,
                        bson_new_sized,
                        bson_new_from_data,
                        bson_finish,
                        bson_reset,
                        bson_free,
                        bson_size,
                        bson_data,
                        bson_validate_key,

                        bson_append_string,
                        bson_append_double,
                        bson_append_document,
                        bson_append_array,
                        bson_append_binary,
                        bson_append_oid,
                        bson_append_boolean,
                        bson_append_utc_datetime,
                        bson_append_null,
                        bson_append_regex,

                        bson_append_javascript,
                        bson_append_symbol,
                        bson_append_javascript_w_scope,
                        bson_append_int32,
                        bson_append_timestamp,
                        bson_append_int64,
                        bson_cursor_new,
                        bson_find,
                        bson_cursor_free,
                        bson_cursor_next,

                        bson_cursor_find_next,
                        bson_cursor_find,
                        bson_cursor_type,
                        bson_cursor_type_as_string,
                        bson_cursor_key,
                        bson_cursor_get_string,
                        bson_cursor_get_double,
                        bson_cursor_get_document,
                        bson_cursor_get_array,
                        bson_cursor_get_oid,

                        bson_cursor_get_boolean,
                        bson_cursor_get_utc_datetime,
                        bson_cursor_get_javascript,
                        bson_cursor_get_symbol,
                        bson_cursor_get_int32,
                        bson_cursor_get_timestamp,
                        bson_cursor_get_int64;


import crack.strutil StringArray;
import crack.ascii hex;
import crack.cont.array Array;

fmt := FStr();

@import crack.ann define;

StringArray basicTypes = ["int", "uint", "int32", "uint32", "int64", "uint64",
                          "byteptr", "float32", "float64",  "array[int]",
                          "array[uint]", "array[int32]",    "array[uint32]",
                          "array[int64]", "array[uint64]", "array[float32]",
                          "array[float64]"
                         ];

StringArray crackTypes = ["int", "uint", "int32", "uint32", "int64", "uint64",
                          "String", "float32", "float", "float64", "bool",
                          "Array[int]", "Array[uint]", "Array[int32]",
                          "Array[uint32]", "Array[int64]", "Array[uint64]",
                          "Array[float32]", "Array[float64]",
                         ];

StringArray crackSizes = ["INT_SIZE", "INT_SIZE", "4", "4", "8", "8",
                          ".size", "4", "8", "8", "INT_SIZE", 
                          ".count()", ".count()", ".count()", 
                          ".count()", ".count()", ".count()",
                          ".count()", ".count()"];
                          
// Serializer for BSON formatter buffers
class BSONBufferSerializer : Serializer {
    bson _b;
    bool _finished;
    bson _tmpBSON = null;

    void _setup(uint bufsize) {
        _b = bson_new_sized(int32(bufsize));
        _finished = false;
        writeId = false;
        writeArraySize = false;
        hasPrefix = true;
        hasPostfix = true;
    }

    oper init() {
        _setup(1024);
    }

    oper init(uint bufsize) {
        _setup(bufsize);
    }

    oper init(FDWriter w) : _b = null {
        throw InvalidResourceError("Not implemented");
    }

    void prefix(Buffer name) {
        _tmpBSON = null;
        if (!(name is null) && name.size > 0) {
            _tmpBSON = _b;
            _b = bson_new();
        }
    }

    void postfix(Buffer name) {
        if (!(_tmpBSON is null)) {
            bson_append_document(_tmpBSON, name.buffer, _b);
            _b = _tmpBSON;
        }
    }

    bson getBSON() {
        return _b;
    }

    void setBSON(bson b) {
        _b = b;
    }

    Buffer serialized() {
        if (!_finished) {
            bson_finish(_b);
            _finished = true;
        }
        return Buffer(bson_data(_b), bson_size(_b));
    }

    @define formatMethod(T, BT, s) {
        void format(T val, Buffer name) {
            if (!bson_append_$$BT(_b, name.buffer, val))
                throw InvalidArgumentError(fmt `Failed to element $name`);
        }
    }

    @formatMethod(int32, int32, 4)
    @formatMethod(int64, int64, 8)
    @formatMethod(float64, double, 8)
    @formatMethod(bool, boolean, 1)

    void format(String val, Buffer name) {
        bson_append_string(_b, name.buffer, val.buffer, int32(val.size));
    }

    @define formatMethodUnsupported(T, RT, BT, s) {
        void format(T val, Buffer name) {
            if (!bson_append_$$BT(_b, name.buffer, RT(val)))
                throw InvalidArgumentError(fmt `Failed to element $name`);
        }
    }

    @formatMethodUnsupported(int, int32, int32, 4)
    @formatMethodUnsupported(uint, int32, int32, 4)
    @formatMethodUnsupported(int16, int32, int32, 4)
    @formatMethodUnsupported(uint16, int32, int32, 4)
    @formatMethodUnsupported(uint32, int32, int32, 4)
    @formatMethodUnsupported(uint64, int64, int64, 8)
    @formatMethodUnsupported(float32, float64, double, 8)
    @formatMethodUnsupported(float, float64, double, 8)
    @formatMethodUnsupported(float32, float64, double, 8)

    @define formatMethodArray(T, BT, s) {
        void format(Array[T] val, Buffer name) {
            fmt := FStr();
            bsonArray := bson_new();
            data := val.data();
            uint cnt = val.count();
            for (uint i; i < cnt; i++) {
                d := fmt `$i\0`;
                if (!bson_append_$$BT(bsonArray, d.buffer, data[i]))
                    throw InvalidArgumentError(fmt `Failed to element $name`);
            }
            bson_finish(bsonArray);
            
            bson_append_array(_b, name.buffer, bsonArray);
        }
    }

    @formatMethodArray(int32, int32, 4)
    @formatMethodArray(int64, int64, 8)
    @formatMethodArray(float64, double, 8)
    @formatMethodArray(bool, boolean, 1)

    @define formatMethodArrayUnsupported(T, RT, BT, s) {
        void format(Array[T] val, Buffer name) {
            fmt := FStr();
            bsonArray := bson_new();
            data := val.data();
            uint cnt = val.count();
            for (uint i; i < cnt; i++) {
                d := fmt `$i\0`;
                if (!bson_append_$$BT(bsonArray, d.buffer, RT(data[i])))
                    throw InvalidArgumentError(fmt `Failed to element $name`);
            }
            bson_finish(bsonArray);
            bson_append_array(_b, name.buffer, bsonArray);
        }
    }

    @formatMethodArrayUnsupported(int16, int32, int32, 4)
    @formatMethodArrayUnsupported(uint16, int32, int32, 4)
    @formatMethodArrayUnsupported(int, int32, int32, 4)
    @formatMethodArrayUnsupported(uint32, int32, int32, 4)
    @formatMethodArrayUnsupported(uint64, int64, int64, 8)
    @formatMethodArrayUnsupported(uint, int32, int32, 4)
    @formatMethodArrayUnsupported(float, float64, double, 4)
    @formatMethodArrayUnsupported(float32, float64, double, 4)

    void format(Array[String] val, Buffer name) {
        fmt := FStr();
        bsonArray := bson_new();
        String d;
        uint cnt = val.count();
        for (uint i; i < cnt; i++) {
            d = fmt `$i\0`;
            bson_append_string(_b, d.buffer, val[i].buffer,
                               int32(val[i].size));
        }
        bson_finish(bsonArray);
        bson_append_array(_b, name.buffer, bsonArray);
    }

    void format(Array[Serializable] val, Buffer name) {
        fmt := FStr();
        bsonArray := bson_new();
        uint cnt = val.count();

        if (cnt > 0) {
            data := val.data();
            bson tmpBson = _b;
            bson elem;
            obj := val[0];

            for (uint i; i < cnt; i++) {
                index := fmt `$i\0`;
                elem = bson_new();
                _b = elem;
                val[i].serialize(this, null);
                bson_append_document(bsonArray, index.buffer, elem);
            }
            _b = tmpBson;            
        }
        bson_append_array(_b, name.buffer, bsonArray);
    }


    void write(Buffer buf) {
        format(buf, null);
    }

    oper del() {
      if (!(_b is null)) {
        bson_free(_b);
      }
    }
}

class BSONBufferMaterializer : Materializer {

    bson _b, _tmpBSON;
    bson_cursor _c, _tmpBSONCursor;
    Buffer _buf;
    

    void _setup() {
        hasPrefix = true;
        hasPostfix = true;
    }
    
    oper init (bson b) : _b = b, _c = bson_cursor_new(b) {
    }

    // We need this for the generator
    oper init() {
        _b = bson_new();
        _c = bson_cursor_new(_b);
        _setup();
    }

    oper init(Buffer buf) : _buf = buf  {
        _b = bson_new_from_data(_buf.buffer, int32(_buf.size));
        _c = bson_cursor_new(_b);
        _setup();
    }

    oper init(FDReader r) : _buf = null {
        throw InvalidResourceError("Not implemented");
    }

    void prefix(Buffer name) {
        _tmpBSON = null;
        _tmpBSONCursor = null;
        if (!(name is null) && name.size > 0) {
            _tmpBSON = _b;
            _tmpBSONCursor = _c;
            if (bson_cursor_next(_c)) { // TODO handle error case
                _b = bson_cursor_get_document(_c);
                _c = bson_cursor_new(_b);
            }
        }
    }

    void postfix(Buffer name) {
        if (!(_tmpBSON is null)) {
            bson_cursor_free(_c);
            bson_free(_b);
            _b = _tmpBSON;
            _c = _tmpBSONCursor;
        }
    }

    Buffer getBuffer() {
        return _buf;
    }

    bson getBSON() {
        return _b;       
    }

    bson_cursor getBSONCursor() {
        return _c;       
    }

    void setBSON(bson newb) {
        _b = newb;
    }

    void setBSONCursor(bson_cursor newc) {
        _c = newc;       
    }

    void _handleError(String tpe) {
        throw InvalidResourceError(
            FStr() `Error $(strerror()) materializing type $(tpe)`
        );
    }
    
    @define formatMethod(T, RT) {
        T format(T val, Buffer name) {
            return T(bson_cursor_get_$$RT(_c));
        }
    }

    bool format(bool val, Buffer name) {
        return bson_cursor_get_boolean(_c);
    }


    @formatMethod(int, int64)
    @formatMethod(uint, int64)

    @formatMethod(int16, int32)
    @formatMethod(uint16, int32)

    @formatMethod(int32, int32)
    @formatMethod(uint32, int32)

    @formatMethod(uint64, int64)
    @formatMethod(int64, int64)
    @formatMethod(float32, double)
    @formatMethod(float64, double)

    // No casting needed
    @define formatMethodArrayDirect(T, RT) {
        Array[T] format(Array[T] val, Buffer name) {
            // Read the array length so we can allocate enough space
            BA := bson_cursor_get_array(_c); // Get the array document
            if (BA is null)
                throw AssertionError(I"Trying to materialize non-array BSON
                                       object as an array");
            cA :=  bson_cursor_new(BA);

            A := Array[T]();
            while (bson_cursor_next(cA))
                A.append(bson_cursor_get_$$RT(_c));
            bson_cursor_free(cA);
            bson_free(BA);
            return A
        }
    }

    @define formatMethodArray(T, RT) {
        Array[T] format(Array[T] val, Buffer name) {
            // Read the array length so we can allocate enough space
            BA := bson_cursor_get_array(_c); // Get the array document
            if (BA is null)
                throw AssertionError(I"Trying to materialize non-array BSON
                                       object as an array");
            cA :=  bson_cursor_new(BA);

            A := Array[T]();
            while (bson_cursor_next(cA))
                A.append(T(bson_cursor_get_$$RT(_c)));
            bson_cursor_free(cA);
            bson_free(BA);
            return A
        }
    }

    @formatMethodArray(int, int64)
    @formatMethodArray(uint, int64)

    @formatMethodArray(int16, int32)
    @formatMethodArray(uint16, int32)

    @formatMethodArrayDirect(int32, int32)
    @formatMethodArray(uint32, int32)

    @formatMethodArrayDirect(int64, int64)
    @formatMethodArray(uint64, int64)

    @formatMethodArray(float32, double)
    @formatMethodArray(float64, double)
    @formatMethodArrayDirect(bool, boolean)

    String format(String val, Buffer name) {
        bytes := bson_cursor_get_string(_c);
        if (bytes is null)
            throw AssertionError("NULL found when materializing String");
        // Make a copy of the string
        return String(bytes, strlen(bytes), false);
    }

    Array[String] format(Array[String] val, Buffer name) {
        // Read the array length so we can allocate enough space
        BA := bson_cursor_get_array(_c); // Get the array document
        if (BA is null)
            throw AssertionError(I"Trying to materialize non-array BSON object
                                   as an array");
        cA :=  bson_cursor_new(BA);

        A := Array[String]();
        while (bson_cursor_next(cA)) {
            bytes := bson_cursor_get_string(_c);
            if (bytes is null)
                throw AssertionError("NULL found when materializing String");
            // Make a copy of the string
            A.append(String(bytes, strlen(bytes), false));
        }

        bson_cursor_free(cA);
        bson_free(BA);
        return A;
    }

    Array[Serializable] formatArray(function[Serializable,
                                    Materializer, Buffer] cons,
                            Buffer name) {
        // Read the array length so we can allocate enough space
        BA := bson_cursor_get_array(_c); // Get the array document
        if (BA is null)
            throw AssertionError(I"Trying to materialize non-array BSON object
                                   as an array");
        cA :=  bson_cursor_new(BA);
        bson tmpBson;

        A := Array[Serializable]();
        while (bson_cursor_next(cA)) {
            tmpBson = _b;
            _b = bson_cursor_get_document(_c);
            if (_b is null)
                throw AssertionError("NULL found when materializing Serializable");
            // Make a copy of the string
            A.append(cons(this, null));
        }

        bson_cursor_free(cA);
        bson_free(BA);
        return A
    }

    class MaterializerIter {
        BSONBufferMaterializer __mt;
        bson_cursor __c = null;
        bson        __b;
        bool __first = true;
        uint __index = 0;
    
        oper init(BSONBufferMaterializer mt) : __mt = mt {
            __b = bson_cursor_get_array(mt.getBSONCursor());
            if (!(__b is null)) // TODO raise exception is not an array
                __c = bson_cursor_new(__b);
        }

        BSONBufferMaterializer elem() {
            return __mt;
        }

        @final
        bool next() {
            if (bson_cursor_next(__c)) {
                __b = bson_cursor_get_document(__c);
                __mt.setBSON(__b);
                __index++;
            }
            else __b = null;
            return !(__b is null);
        }

        @final
        bool nx() {
            if (__first) {
                __first = false;
                return !(__b is null);
            } else {
                return next();
            }
        }
        
        @final uint _getIndex() { return __index; }
        
        bool isTrue() {
            return !(__b is null);
        }

        oper del() {
            bson_cursor_free(__c);
            if (!(__b is null))
                bson_free(__b);
        }
    }

    MaterializerIter iter() {
        return MaterializerIter(this);
    }


    void write(Buffer buf){
        format(buf, null);
    }

    oper del() {
      if (!(_b is null)) {
        bson_free(_b);
      }
    }
}
