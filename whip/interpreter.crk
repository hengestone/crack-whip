import crack.cont.hashmap HashMap;
import crack.io FStr, cerr, cout, FileHandle;
import crack.io.readers LineReader;
import crack.lang CString, Exception, Formatter;
import crack.net Pipe;
import crack.process Process;
import crack.regex escape, Regex, Match;
import crack.runtime errno;
import crack.strutil StringArray;
import crack.sys env, strerror;
import crack.cont.array Array;
import whip.entity Entity;

// Interpreter is a client that connects to a Unix socket, then forks to make the
// socket available to an interpreter process (bash, ruby, python etc)

class IntProcess : Process {
  oper init(String cmd): Process(cmd) { }
  oper init(StringArray args, HashMap[String, String] envMap): Process(args, envMap) {}
  int getInputFD() { return _pd.stdin; }
  int getOutputFD() { return _pd.stdout; }
  int getErrFD() { return _pd.stderr; }
}

const int INTP_READY = 0,
          INTP_BUSY = 1,
          INTP_ERROR = 2,
          INTP_DONE = 3;

HashMap[String, int] statusMap = {};
statusMap["READY"] = INTP_READY;
statusMap["BUSY"] = INTP_BUSY;
statusMap["ERROR"] = INTP_ERROR;
statusMap["DONE"] = INTP_DONE;


@abstract
class Interpreter {
  IntProcess _process;
  StringArray _statusCmds;
  int status = -1;

  @abstract
  oper init(StringArray cmd, StringArray statusCmds) : _statusCmds = statusCmds { }

  @abstract
  Array[FileHandle] getFileHandles();

  @abstract
  int id();

  @abstract
  int dataReady(FileHandle f);

  @abstract
  int stop();

  @abstract
  int exe(String script);
}

// An intepreter that spawns a subprocess and creates a pipe to read status from
class SimpleInterpreter : Interpreter {
  Array[Pipe] pipes;
  Array[FileHandle] _pollables;
  HashMap[int, LineReader] readers = {};
  Regex _rx;

  oper init(StringArray cmd, StringArray statusCmds) :
    Interpreter(cmd, statusCmds), _rx = Regex('status:([A-Z]+).*'), pipes()
  {

    if (statusCmds.count() !=4)
      throw Exception("Array of statusCmds must have 4 entries");
    _statusPipe := Pipe();
    _statusPipe.setNonBlocking(true);
    pipes.append(_statusPipe);

    addr := _statusPipe.getAddr();
    env["WHIP_WRITEFD"] = FStr() `$(addr.writefd)`;
    env["WHIP_READFD"] = FStr() `$(addr.readfd)`;
    _process = IntProcess(cmd, env);

    if (_process.getOutputFD() == -1){
      throw Exception(FStr() `Unable to start interpreter $(cmd[0]): $(strerror())\n`);
    }
    
    _statusPipe.setReader();
    _statusFH := FileHandle(addr.writefd);
    _statusFH.close(); // So we don't directly import runtime.close

    _stdoutPipe := Pipe(int32(0), int32(_process.getOutputFD()), -1);
    _stdoutPipe.setReader();
    _stdoutPipe.setNonBlocking(true);
    pipes.append(_stdoutPipe);

    _stderrPipe := Pipe(int32(0), int32(_process.getErrFD()), -1);
    _stderrPipe.setReader();
    _stderrPipe.setNonBlocking(true);
    pipes.append(_stderrPipe);

    _statusPipeReader := LineReader(_statusPipe);
    _stdoutPipeLineReader := LineReader(_stdoutPipe);
    _stderrPipeLineReader := LineReader(_stderrPipe);

    readers[_statusPipe.getFD()] = _statusPipeReader;
    readers[_stdoutPipe.getFD()] = _stdoutPipeLineReader;
    readers[_stderrPipe.getFD()] = _stderrPipeLineReader;

    if (_statusCmds[INTP_READY])
      _process.putStdIn(_statusCmds[INTP_READY]);
    
    _pollables = Array[FileHandle]![FileHandle(addr.readfd),
                  FileHandle(_process.getOutputFD()) ];
  }

  Array[FileHandle] getFileHandles(){
    return _pollables;
  }

  int stop() {
    _process.close();
    return 0;
  }

  int id(){
    return pipes[0].getFD();
  }

  int exe(String script){
    status = INTP_READY;
    if (_statusCmds[INTP_BUSY])
      _process.putStdIn(_statusCmds[INTP_BUSY]);
    _process.putStdIn(script);
    if (_statusCmds[INTP_DONE])
      _process.putStdIn(_statusCmds[INTP_DONE]);
    return script.size; // TODO, get real number of bytes sent
  }

  int dataReady(FileHandle f){
    int changes=0;
    try {
      fd := f.fd;
      lr := readers.get(fd, null);
      if (lr){
        for (lineItem :in lr){
          cerr `$lineItem`;
          m := _rx.search(lineItem);
          if (!m) {
            continue;
          }
          g := m.group(1);
          int s = -1;
          if (g) {
            s = statusMap.get(g, -1);
            if (s>=0) {
              status = s;
              changes++;
              break;
            }
          }
        }
      }
      else {
        cerr `FileHandle($fd) not found!\n`;
      }
    }
    catch(Exception ex){
      err := errno();
      if (err != 11)
        cerr `readline failed: $(strerror())\n`;
    }
    return changes;
  }

  void formatTo(Formatter fmt){
    fmt `SI: $(id())`;
  }
}

class ShellInterpreter : SimpleInterpreter {
  oper init() :
    SimpleInterpreter(StringArray!["/bin/bash", "-s"],
                      StringArray!['echo "status:READY" >&$WHIP_WRITEFD\n',
                                   'echo "status:BUSY" >&$WHIP_WRITEFD\n',
                                   'echo "status:ERROR" >&$WHIP_WRITEFD\n',
                                   'echo "status:DONE" >&$WHIP_WRITEFD\n'])
  { }
}

class RubyInterpreter : SimpleInterpreter {
  oper init() :
    SimpleInterpreter(StringArray!["/usr/bin/irb", "--noprompt", "--noreadline", "-f"],
                      StringArray![
r'IO.open(ENV["WHIP_READFD"].to_i).close()
__whip_status_io = nil
begin
  __whip_status_io = IO.new(ENV["WHIP_WRITEFD"].to_i, "w")
  __whip_status_io.sync = true
rescue
  STDERR.write("Unable to open __whip_status_io\n")
end
__whip_status_io.syswrite("status:READY ruby\n")
',
                                   '__whip_status_io.syswrite("status:BUSY ruby\\n")\nbegin\n',
                                   '__whip_status_io.syswrite("status:ERROR ruby\\n")\n',
                                   'end while false\n__whip_status_io.syswrite("status:DONE ruby\\n")\n'])
  { }
}
