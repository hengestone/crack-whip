// Test for Entity class
import crack.io FStr, cerr;
import crack.logger cerrLogger, DEBUG, ERROR;
import crack.net Poller, POLLIN, POLLOUT;
import crack.runtime exit;
import crack.strutil StringArray;
import crack.time TimeDelta, seconds;
import whip.interpreter ShellInterpreter, RubyInterpreter, INTP_DONE,
                        INTP_BUSY, INTP_READY, INTP_NEW, Interpreter;
import whip.sockserver InterpreterContainer;


bool waitForStatus(InterpreterContainer server, Interpreter intp, int status, TimeDelta delay){

  while (intp.status != status) {
    changes := server.processOnce(delay);
    cerrLogger.debug(FStr() `startup: status = $(intp.status), changes = $changes`);
  }
  return true;
}

cerrLogger.setLevel(ERROR);
cerrLogger.setNamedFields("progname datetime severity msg");
server := InterpreterContainer(cerrLogger);
delay := seconds(1);

#~ ShellInterpreter intp = {};
#~ server.add(intp, intp.getFileHandles()[0]);
RubyInterpreter rintp = {cerrLogger};
rintp.setMaxCmds(5);
rintp.start();
server.add(rintp);

// Sleepy wait for server to become ready
waitForStatus(server, rintp, INTP_READY, delay);
int oldstatus = rintp.status;
int i = 0;

while (i<11){
  if (rintp.status == INTP_NEW){
    rintp.start();
    cerrLogger.debug("Waiting for startup...");
    waitForStatus(server, rintp, INTP_READY, delay);
  }

  if (rintp.exe(FStr() `puts('hello ruby $(i)' )\n`) == -1)
    break;
  while (rintp.status != INTP_READY && rintp.status != INTP_NEW) {
    changes := server.processOnce(delay);
    cerrLogger.debug(FStr() `$i: status = $(rintp.status), changes = $changes`);
  }
  i++;
}
