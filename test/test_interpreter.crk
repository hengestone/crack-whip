// Test for Entity class
import crack.io FStr, cerr;
import crack.logger cerrLogger;
import crack.net Poller, POLLIN, POLLOUT;
import crack.runtime exit;
import crack.strutil StringArray;
import crack.time TimeDelta, seconds;
import whip.interpreter ShellInterpreter, RubyInterpreter, INTP_DONE,
                        INTP_BUSY, INTP_READY, INTP_NEW, Interpreter;
import whip.sockserver InterpreterContainer;


bool waitForStatus(InterpreterContainer server, Interpreter intp, int status, TimeDelta delay){

  while (intp.status != status) {
    changes := server.processOnce(delay);
    cerr `startup: status = $(intp.status), changes = $changes\n`;
  }
  return true;
}

server := InterpreterContainer(cerrLogger);
delay := seconds(1);

#~ ShellInterpreter intp = {};
#~ server.add(intp, intp.getFileHandles()[0]);
RubyInterpreter rintp = {cerrLogger};
rintp.setMaxCmds(5);
rintp.start();
server.add(rintp);

// Sleepy wait for server to become ready
waitForStatus(server, rintp, INTP_READY, delay);
int oldstatus = rintp.status;
int i = 0;

while (i<10){
  oldstatus = rintp.status;
  if (rintp.exe(FStr() `puts('hello ruby $(i)' )\n`) == -1)
    break;
  if (oldstatus == INTP_NEW){
    cerr `Waiting for startup...\n`;
    waitForStatus(server, rintp, INTP_BUSY, delay);
  }
  while (rintp.status != INTP_READY && rintp.status != INTP_NEW) {
    changes := server.processOnce(delay);
    cerr `$i: status = $(rintp.status), changes = $changes\n`;
  }
  i++;
}
