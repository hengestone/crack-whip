====
whip
====

An IDL parser and code generator for XDR, JSON and BSON
-------------------------------------------------------
Originally started as a dependency manager (or DAG manager) for network
jobs, **whip** currently is most useful for *generating class definitions and
serialization/deserialization of objects defined using an interface
description language*.

Introduction
------------
When writing web services and distributed network serices, such as those using
the Crossroads IO library I've found it useful in the long run to specify these
interfaces explicitly outside the code.

**whip** follows the example of the Protocol Buffers implementation of it's IDL,
with a syntax that is close to that of the *Crack* language itself, which in
turn is similar to the PB IDL.

Interface Definition Language
-----------------------------
Interfaces are specified as (possibly nested) messages, with all primitive types
of the *Crack* language supported.

For example from the file ``test/test_serialize.whipdl`` file in the
distribution:

::

    message testSerialize {
        int int1 = -1;
        uint uint2 = 1;
        int32 int3 = 2;
        uint32 uint4 = 3;
        String S = "Hello";
        Array[int] A = [10];
    }

This message definition looks almost identical to a *Crack* class definition
and can contain default values for members. Lines end with a semicolon as they
would in *Crack*.

More complex messages can be defined using already defined message names as
types. E.g.

::

    message testContainer {
        testSerialize T;
    }

Or

::

    message testContainer {
        Array[testSerialize] T;
    }

Messages can be defined in different files and included in others:

::

    import "test_message.whipdl";

    message testContainer {
      Array[testSerialize] T;
    }

The *import* statement is followed by the name of the file and ends in a
semicolon.

Code generation using *whipclass*
---------------------------------

Class definitions are generated using the ``whipclass`` command. Currently
only the *Crack* generator is up to date, and is the default. There is also
some support for Ruby code generation.

For the ``testSerialize`` message above defined in the
``test_message.whipdl`` file, the class definition can be generated using:

::

    whipclass --idl=test_serialize.whipdl --out=test_serialize.crack

The class derives from an abstract ``Serializable`` class in the
``whip.serializer`` namespace. In order to use the class definition, the
file can simply be imported:

::

    import test_message testSerialize;

Serializing and deserializing messages
--------------------------------------
In order to create a serialized representation of objects of type
``testSerialize``, we need a ``Serializer``, or ``Materializer`` for the
inverse operation:

::

    import whip.json_serializer JSONBufferSerializer, JSONBufferMaterializer;
    sr := JSONBufferSerializer();


Objects can be created using the default constructor and
serialized as follows:

::

    message := testSerialize();
    message.serialize(sr);
    data := sr.serialized();

The serialzed JSON text will be:

::

    {"int1": -1, "uint2": 1, "int3": 2, "uint4": 3, "S": "Hello", "A": [10]}

To materialize an object we use the data ``Buffer`` to construct a
Materializer which can be passed as an argument to a constructor for the
generated class:

::

    mt := JSONBufferMaterializer(data);
    newmsg := testSerialize(mt);

The same can be done with ``BSONBufferSerializer``/ ``BSONBufferMaterializer`` and 
``XDRBufferSerializer``/ ``XDRBufferMaterializer``.

Example class
-------------
The class definition generated by the above test message looks as follows:

::

    class testSerialize : Serializable {
      uint32 __id = 0x33a98818;
      uint32 getId() { return __id; }
      int int1 = -1;
      uint uint2 = 1;
      int32 int3 = 2;
      uint32 uint4 = 3;
      String S = "Hello";
      Array[int] A = [10];
      oper init() { }


      void serialize(Serializer sr, Buffer name) {
        uint i = 0;
        sr.prefix(name);
        sr.format(int1, "int1");
        sr.format(uint2, "uint2");
        sr.format(int3, "int3");
        sr.format(uint4, "uint4");
        sr.format(S, "S");
        sr.format(A, "A");
        sr.postfix(name);
      }

      void serialize(Serializer sr) {
        serialize(sr, null);
      }

      uint sizeNeeded() {
        uint cnt = 4;  // The 32bit id is always there
        cnt += INT_SIZE; // int1
        cnt += INT_SIZE; // uint2
        cnt += 4; // int3
        cnt += 4; // uint4
        cnt += S.size + (4 - (S.size)%4); // S
        cnt += A.count() + (4 - (A.count())%4); // A
        return cnt;
      }

      void materialize(Materializer mt, Buffer name) {
        mt.prefix(name);
        int1 = mt.format(int1, "int1");
        uint2 = mt.format(uint2, "uint2");
        int3 = mt.format(int3, "int3");
        uint4 = mt.format(uint4, "uint4");
        S = mt.format(S, "S");
        A = mt.format(A, "A");
        mt.postfix(name);
      }

      void materialize(Materializer mt) {
        materialize(mt, null);
      }

      oper init(Materializer mt, Buffer name) {
         materialize(mt, name);
      }

      oper init(Materializer mt) {
         materialize(mt, null);
      }
    }




