// Class generator command-line utility
// Copyright 2012 Conrad Steenberg <conrad.steenberg@gmail.com>
// 7/17/2012

import crack.cmdline CmdOptions, Option, CMD_STR, CMD_INT, CMD_FLOAT, CMD_BOOL;
import crack.io cout, cerr, FStr;
import crack.runtime exit;
import crack.sys argv;

import whip.utils.crack_generator CrackClassGenerator;
import whip.utils.generator Message;
import whip.utils.idl_parser idlParser;
import whip.utils.ruby_generator RubyClassGenerator;
import whip.utils.ruby_xdr_serializer rubyTypes, rubySizes;
import whip.xdr_serializer crackTypes, crackSizes, XDRBufferSerializer,
                           XDRBufferMaterializer;
import whip.json_serializer JsonBufferSerializer, JsonBufferMaterializer;

CmdOptions options = [Option("help",        "h", "Show help message", "f", CMD_BOOL),
                      Option("idl",         "i", "IDL file to parse", "", CMD_STR),
                      Option("out",         "o", "Name of output file", "", CMD_STR),
                      Option("lang",        "l", "Output language", "crack", CMD_STR),
                      Option("serializer",  "s", "Serializer [json,xdr]", "json", CMD_STR),];

// Parse options passed by the system
options.parse(argv, false);

void usage(CmdOptions options){
  options.printUsage(FStr() `Usage: $(argv[0]) [OPT1] [OPT2] file\n`);
}

if  (options.getBool("help") || options.getString("idl").size == 0){
  usage(options);
  exit(0);
}

// Create parser
idlParser parser;
lang := options.getString("lang");
if (lang == "crack")
  parser = idlParser(CrackClassGenerator(crackTypes, crackSizes));
else if (lang == "ruby")
  parser = idlParser(RubyClassGenerator(rubyTypes, rubySizes));
else {
  cerr `Unknown output language $lang, must be one of "crack" or "ruby"\n`;
  exit(1);
}

parser.parseFile(options.getString("idl"));

// Create serializer
serializer := options.getString("serializer");
if (serializer == "json")
    parser.gen.create(cout, JsonBufferSerializer(), JsonBufferMaterializer());
else if (serializer == "xdr")
    parser.gen.create(cout, JsonBufferSerializer(), XDRBufferMaterializer());
else  {
  cerr `Unknown output serializer $serializer, must be one of "json" or "xdr"\n`;
  exit(1);
}
